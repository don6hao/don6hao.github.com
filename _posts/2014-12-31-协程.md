---
layout: post
title: "Python-协程"
description: "协程/yield"
category: Python
tags: []
---

协程
---
协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。

​对比多线程优势：

1. 因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
2. 协程不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

yield
---
Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。

    def fab(max): 
        n, a, b = 0, 0, 1 
        while n < max: 
            yield b 
            # print b 
            a, b = b, a + b 
            n = n + 1
    for i in fab(5):
        print i

yield的作用就是把一个函数变成一个 generator，Python 解释器会将其视为一个generator.
调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！
在for循环执行时，每次循环都会执行fab函数内部的代码，执行到yield b 时，fab 函数就返回一个迭代值，
下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。
